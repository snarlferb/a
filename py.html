<!-- real python -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Would you eat them in a box?</title>
<meta content="width=device-width,initial-scale=1,user-scalable=no" name=viewport>
<script src="style.js" defer></script>
</head><body><h3><u>Warning</u>! Learn C before you learn python</h3><b>This is the green eggs &amp; ham that make up Pythons indigestible layer.
<em>To illustrate the loopiness caused by the equality of identifiers, here's a rule of thumb, and what I'll ultimately be focusing on:</em></b>
     <a href="https://imgur.com/EMJctVN"><img src="https://i.imgur.com/EMJctVN.jpg" title="source: imgur.com" /></a>
  &#183 A value passed, always starts from the last (or sum)
  &#183 Iteration in Python is structured around unpacking objects, e.g. for key:value (what for loops amount to)
  &#183 Parameters can be treated as objects, functions can be assigned or passed as arguments,
    and types can be inherited or modified dynamically (therefore everything can be accessed
    through everything)
  &#183 Comprehensions (consolidating expressions) and generators construct iterable objects,
    while multi-variable unpacking assigns values in bulk.

  <em>That's a lot of big words. If it doesnt make sense, humour me for now.</em>

The significance of Python is in how it gives you the feel for high order systems/design motifs. Python
lets you see relationships between values, operations, and abstract concepts. When used correctly, you
can see that programming is itself a layering of abstractions, where different implementations have an
upside /or downside, in regards to flexibility (ergo, programming towards efficiency). Now when side by
side next to C, Python can seem quite similar. Although, fundamentally, Python has eminent differences:
<span class="alt-text">
  def foo(p):
      print(p)
  def spam(reassign):
      foo(reassign)
  variable = 8
  spam(variable)</span>

We are reassigning and calling a function, because you dont declare things in Python
instead you would do something similar, where a function is created and variables are assigned.

Lets back up for a second. In Python and other languages like Python, you can annotate variables using
a syntax similar to function parameter annotations, with a colon (:) followed by the type, for example:
<span class="alt-text">
  x: int = 9</span>

One difference that stands out, is that there isnt any unsigned integers in Python, as Python's `int`
supports arbitrary precision, so it can represent values beyond typical 32-bit or 64-bit ranges (without overflow)

The calling convention-system for calling functions in Python is not like C where you are thinking
in terms of framework headers and graphics library headers. Instead, you have to call a function
on an "as needed" basis. Python (and other similar languages) are like functions inputted into
a calculator. Everything from passing parameters to assigning functions is simplified, and it
doesnt enforce any rules on where a function signature is and subsequent type annotations, as
functions are **first-class objects**, wherein they can be passed as arguments or assigned as
variables in a **free-for-all** manner. It also doesnt matter if you use a `TAB` character for
indenting (to define a statement block), as you can <em>choose</em> the indentation level.
With that said its common convention to use <b>4xspaces</b>.

You can think of Python like your trying to create functions inside `main.c`,
where you call them at the end (`int main`), thats reminiscent to a python script.
<span class="alt-text">
  def sum(iterable, start=0):
      total = start
      for item in iterable:
          total += item
      return total</span>

<b>For loops can have a `key:value` type format</b>. Also, Python's capable of assigning a default value
during the parameter of the function. Things are already quite different it seems, yah? Once you can wrap
your head around For loops, and arrays, etcetera, you'll most certainly have 50% of the battle cleared:
<span class="alt-text">
  for key, value in function(param):</span>

this `key:value` concept is essential to python, or pythons methodology. There is also this inherent consolidation behavior of functions,
where different functions hold different values, and calling `print(result)` would output the consolidation of those values

<b>Python's "invoking" behavior is such that if you pass in a value, it's always starting from the sum or (last) by default</b>
<span class="alt-text">
  def func(x):
      def inner(y):
          return x + y
      return inner
  newFunc = func(5)
  result = newFunc(3) #Outputs 8</span>

<em>In the example above, `inner` is a closure that captures the variable `x` from the enclosing scope of `func`
"currying" carries over/translates the evaluation of a function-closure that took multiple arguments</em>
<span class="alt-text">
  def func(x, y):
      return x + y
  double = partial(func, 3)
  result = double(5) #Outputs 8</span>

<em>partials capture the instructions and assign a variable within its parameters...</em>
<span class="alt-text">
  def add(x, y):
      return x + y
  def execFunc(func, x, y):
      return func(x, y)
  result = execFunc(add, 5, 3) #Outputs 8</span>

here, you can also produce the same functionality without doing anything special.
Think of function parameters like contiguous blocks of memory that you access.
You can embed these concepts within each other (as well as return an anonymous function (lambda))
as this is the main idea behind Python, it makes functions have "composability", such as passing
a function as a parameter or assigning it to another function... It then further consolidates when
you assign it and pass in a value. if you are someone who's against these implicit, non-obvious things,
Python allows some forms of explicitness.

  &#183 `:` after a variable annotates "type", as it also represents the end of a `func(var:type):`
  &#183 And you can use an arrow, e.g. `func(var)-&gt;type:` to specify return type.
  &#183 The end colon after `func():` or `type:` marks the end of the function signature,
    or the beginning of the function body, whichever way you prefer to look at it.
  &#183 Arrays start at 0, per usual. And u have 'slices', and 'range' specification
    e.g. `1:4:2` <em>(i.e. start at 1, stop at 4, and step through every 2 elements)</em>
  &#183 In conclusion a colon denotes type, the end of a signature (or statement),
    or a delimeter between values (including key:value pairs)

<b>more implicit</b>

  &#183 The assignment expression operator `:=` allows you to assign values to variables as yet another consolidated form of expression,
    as it allows you to assign things within an r-value expression. In certain cases you have to wrap the expression within `()` brace
    delimeters, e.g. ` exp = [(y := x**2) for x in nums] `, as without the braces around the expression, the assignment <b>would not
    happen</b> before the value was utilized in the list (the value `y` that is placed into the list during the iteration)
  &#183 By simply using (e.g. comparison operators) Python infers a boolean output.
  &#183 For loops let you specify names you havent even declared, i.e. `my_named_key:my_named_pair` format i explained...

<b>For loops in Python are just statements, and these statements can iterate over another sequence or statement</b>
<span class="alt-text">
  def gen_num():
    for i in range(5):
      yield i
  for number in gen_num():
      print(number)</span>

If you dont include `yield`, then you cant specify the variable from the function you want to use
<span class="alt-text">
  def countdown(start):
      while start &gt; 0:
          yield start
          start -= 1</span>

In this e.g. `countdown` is a generator function that takes a `start` parameter. Inside the function,
there's a while loop that continues as long as `start` is greater than 0. Within each iteration of the loop,
it yields the current value of `start` and decrements it by `start-1`
You can use this generator function w/ `next()`
<span class="alt-text">
  gen = countdown(5)
  print(next(gen))</span>    <em>#Outputs 5</em><span class="alt-text">
  print(next(gen))</span>    <em>#Outputs 4</em></span>

And it saves you from having to recall `gen = countdown(...)`

Theres a few other things that involve arrays and iteration in Python, however theres another thing called
Generator Expressions (Comprehension), that is to say you can have set comprehension for e.g.
<span class="alt-text">
  function = {num**2 for num in range(5)}</span>

<em>Which is equivalent to if you were finding the square for the index (num) inside the loop every iteration</em>
Notice whole expressions that use comprehension go inside the delimeter tokens (e.g. curly-braces)

There's a technical fact about the asterisk   `**`  is the n^2, squaring operator. But you might also see
`*` or `**kwargs` <em>(variadic parameters)</em> before args to indicate that there is "other" parameters,
however the double asterisk is only for dictionaries... It can also be used IN PLACE OF a parameter,
which represents that every argument after it is "ordered, and explicitly named" in its use;
Like, a technical indicator. </em>(same is the case for `/` which specifies the parameters before)</em>
Pointers in Python arent a thing.

`range(5)` is equivalent to, n &lt; 5, and it starts at 0 by default, or you could have also specified the
start e.g. 1 in the loop `range(1,5)`

Theres a few methods/functions for string manipulation in Python, but the underlying mechanism remains the same;
strings are sequences of characters, each character has an index (position) within the string, and each character
is represented by an underlying, numerical ASCII value

You dont have structs in Python, but you do have classes which are kindve like structs in some sense.
You designate a private class `__name` w/ two underscores, and you can gain access to whatever it is
associated w/, through a public (no underscores) class, that returns the same argument.
It is also recommended by Python to use a getter method associated w/ private/public.
</em>(which is where we might talk about `@property` decorator...)</em>

Firstly, a decorator is a function that wraps another function (or method/class) to modify its behavior
without changing its code. It’s often used for code reuse, logging, enforcing rules, or modifying function outputs.

They do not require the `@decorator_name` above (above the function definition). Using @decorator_name is just
syntactic sugar for applying a function wrapper in a clean way. Also, the @ syntax only works when the decorator
function is known at definition time.
<span class="alt-text">
  def repeat(n):
    def decorator(func):
        def wrapper():
            for _ in range(n):
                func()
        return wrapper
    return decorator

  def say_hello():
    print("Hello!")

  decorated_hello = repeat(3)(say_hello)</span>  <em># Applying manually</em><span class="alt-text">
  decorated_hello()</span>

You can have two concurrent arguments like that because Python functions can return other functions, allowing
multiple layers of function calls.

The @property decorator in Python is used to define getter methods in an object-oriented way, allowing you to
access methods as if they were attributes. It provides a cleaner syntax while still allowing logic to be
executed when retrieving a value. We'll demonstrate some OOP examples at the end.

My favorite decorator is  @lru_cache, for example:
<span class="alt-text">
  @lru_cache(maxsize=3)
  def square(x):
    print(f"Computing square of {x}...")
    return x * x</span>

@lru_cache is a built-in example of memoization. Memoization is a technique used to cache function results,
so that if the function is called again with the same input, it returns the cached result (instead of redoing the work)
That is, it automatically remembers function results so that repeated calls w/ the same inputs return instantly instead of recomputing.
Anytime you have repeated calls to said function, that's when you would utilize it.

<em>You might have also noticed the `_` underscore used as a placeholder/disposable (We'll talk about more about these)</em><h3><u>Python Arra</u>ys (which are also a `type` of said array)</h3>  &#183 brackets `[]` refer to a `list`
  &#183 curly-braces `{}` refer to either a `dictionary`, a `set` or a `frozenset`...
  &#183 braces `()` refer to a `tuple`

<b>Mutability &amp; Order</b>

  &#183 <em>mutable</em> arrays can be changed, and <em>immutable</em> arrays cannot be.
  &#183 <em>order</em> refers to the sequence of elements within data structures. so an unordered array will presumably be "out of order" during operations

<b>Ordered arrays</b> <em>(as of Python 3.7 for dictionaries)</em>

  <span class="alt-text">  list = ["mutable", "elements"]</span>
  <span class="alt-text">  dict = {'mutable_key': 'mutable_val'}</span>
  <span class="alt-text">  tuple = ("immutable", "elements")</span>

<b>Unordered arrays</b>

  <span class="alt-text">  set = {"mutable", "elements"}</span>
  <span class="alt-text">  frozenset = {"immutable", "elements"}</span>

<b>In summary</b>
- I portrayed arrays in this way to demonstrate the syntax and what they are, but there isnt a prejudice on the kind of data you decide upon.

<b>Rememberance</b>
- `list` look the most like a regular array to me, so its probably better to think of lists first, <em>"arrlist"</em>
- `dictionary` <em>{'a collection/interpolation of key values'}</em> i call it a <em>"KeyPair Set"</em>
- `tuple` <em>("immutable")</em> you could think of a tuple as a regular function, in array form,
  more over, a tuple just means a finite sequence/ordered list of numbers.

<b>Purpose</b>
- Use a `list` when you want an ordered collection of elements. Use a `set` if the order doesnt matter and
each element is unique in some other regard. Sets can be associated with the `union()` method

<b>More behavior</b>
- And you can have multiple items within an element e.g. `[3.14, {item1, item2}]` ... is a set within a list and that set has two items

<b>Comments</b>
- Python will accept single or double quotes for key-value pairs, and the same for strings/and f'strings... <em>its a common Unix trait</em>
Hash `#` denotes a comment, and you can use `"""` triple quotes around internal comments, which is the convention for <em>`docstrings`</em>. see <em>`f'strings`</em>

<b>Other Types</b>
- `bytearray` is a smaller type of list. `bytes` represents an immutable sequence of bytes. `bool`, `int`, `complex` and `str` are also all immutable types

If you link to `import numpy as np` you have access to vectors
<span class="alt-text">
  arr = np.array([1, 2, 3])</span>

Note, that it is distinct from a tuple because its mutable.
Also note, that the standard way to create 2D or multi-dimensional array
in Python is to create a list within a list. This is that list when
it has been annotated (i.e. type hints) and w/ the return type, both
of which are optional and are not important to way it functions...
<span class="alt-text">
  def ex(my_array: list[list[int]]) -&gt; int:</span><em>
    """
    Everything ^, besides the function and parameter name are optional.
    This function takes a 2D list of integers and returns an integer.
    (End of our internal comment. Implementation to be added later)
    """
    # Placeholder for the actual implementation
    # We'll just return 0 to satisfy the type hint</em><span class="alt-text">
    return 0</span>

And, because we know that you dont predefine, like in statically
declared languages, you instead are going to assign-call `ex(mat)`,
passing the list of lists, such that it is invoking `ex(my_array:...){...}`
<span class="alt-text">
  mat = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
  result = ex(mat)</span>

Let's look at how a linear function can be implemented...
<span class="alt-text">
  def linear_function(x):
      m = 1</span><em>  # Slope</em><span class="alt-text">
      b = 0</span><em>  # Y-intercept</em><span class="alt-text">
      return m * x + b
  x1 = 0
  x2 = 10</span>

<em>Find points between x1 and x2...</em>
<span class="alt-text">
  x_values = range(x1, x2 + 1)
  points = [(x, linear_function(x)) for x in x_values]</span>

If a variable is not found in the local scope, Python then looks in the enclosing scope.
In this case, the enclosing scope is the global scope (the main part of the script)
Therefore, we could have assigned `x1` an `x2` before defining `def linear_function()`,
and it still would have been able to find both `variable = values` there.

Note, that the lines ^above are syntactical sugar for...
<span class="alt-text">  
  x_values = range(x1, x2 + 1)
  points = []
  for x in x_values:
    points.append((x, linear_function(x)))</span>

The only situations where you are really critical of the scope of a variable is in the
case of variables within functions that are local to the function (not accessible outside)
as well as in the case with classes. And, if you have nested functions, those inner functions
have access to variables from said outer functions (enclosing) scope.

If you want to use a variable defined in one Python file (module) in another file, you must import the module.
Simply having the variable defined in another file doesn't make it accessible.

And if you have a local variable with the <b>same name</b> as a global variable, the local variable "shadows"—
or takes precedence over—the global variable within the function's scope.

<b>Convention and Style Guide</b>
Conventionally speaking, and as a part of Python's style guide, a variable written in all CAPS should be indicative of a
"constant" variable, wherein said variables name/value doesnt change, and <b>shouldnt be changed</b> thereafter. Consider
that we have been portraying all the examples using "best conventions" so far, for functions, variables, etc.

We mentioned how a single underscore character (_) can be used as a placeholder/throwaway variable, and it is a good example
of something in Python that is conventionally used, as opposed to being strictly enforced as a rule...

If you are familiar w/ the `static` keyword in C, and how it restricts the scope of a variable or function to the file in
which it appears, preventing other files from accessing it. If you imagine it as a conventional name (in its global context)
then it would have the same meaning as a single underscore applied to a global variable in Python (e.g. `_internal_object`)

Its still accessible, but the underscore declares it as private, and should not be used outside of the class/module where it appears.

A double underscore before an attribute or method (e.g., __variable) causes name mangling (it tacks on the class name as a
prefix on the original name). This means Python makes the name change internally to avoid name collisions, particularly
in subclasses, and is less likely to be overridden somehow, or accessed from outside the class.

Double underscores around method names indicate special methods (also called magic methods or dunder methods) in Python.
These methods are automatically called by Python in certain situations (e.g., when using operators or certain functions).
Their primary purpose is to allow objects to behave in a specific way when interacting with built-in functions or operators.

Theres a couple different things about Python functions, and that is, if you only specify one/two variables in the parameter,
it will just assume the rest, for example `range` takes three parameters, but you can just give it the `stop` variable (others are optional)

`x` and `y` coordinates are being specified within the tuple `(x, linear_function(x))`, and we're iterating `x2`, and the Y-intersect
starts at 0 and increases by `x2` every iteration. `x` starts at 1, but increases by `x2`. This represents a simple line segment for y=mx+b,
and conceivably, you can change those values.

  <b>m = ∆y/∆x</b>

So, for a line where (m = 1), this means that for every 1 unit increase in `x` (horizontal movement), `y` also increases by 1 unit (vertical movement).
This creates a situation where the line rises at an angle where the vertical and horizontal movements are equal in length, forming a 45-degree angle with the x-axis...

  <b>tan(I) = opposite/adjacent</b>
  <b>tan(I) = ∆y/∆x = 1</b>

<em>nevermind the math, i just wanted to throw that in</em>

<b>Example2:</b> Consider a function `doclip`, which has this argument; `for i in range(3, len):` ... and we're iterating over the arrays
`L` and `R` starting from index 3, up until (len - 1) </em>(A technical fact about `range`, is that it goes up to (but not including) length  - 1)</em>

But lets also look at the linear interpolation part
<span class="alt-text">
  out[i] = L[i] + (f * ((R[i] - L[i]) &gt;&gt; HH_P))</span>

It calculates a linear interpolation between the corresponding elements of `L` and `R`. The result is stored in the `out` array
at the same index `i`. This operation is part of the clipping process for coordinates other than `x`, `y`, and `z`

After the loop, there is a separate operation
<span class="alt-text">
  out[2] = L[2] + (fhp * (R[2] - L[2]) &gt;&gt; 15)</span>

This specifically handles the z-coordinate with extra precision. It performs a similar linear interpolation between the
z-coordinates of `L` and `R` and stores the result in the `out` array at index 2

There was something way back i was interested in, in math, which had to do with odd/even. That could be interesting if
you think about it since it spans the entirety of every 2 numbers, you can conceivably do any kindve operation at any distance.
You can use the modulo operator to do operations on odds, perhaps we'll use it in the context of Python: <em>% = mod operator</em>
<span class="alt-text">
  sequence = [1,2,3,4,5,6,7,8]
  oddElements = [x for x in sequence if x % 2 != 0]
  print(oddElements)</span>

This was another example how Python lets you use conditions within another condition, as well as during assignment.
And if you dont understand the modulo operator, here's a better demonstration </em>[ex. 14 mod5]</em>

  5 goes into 14, (2x)
  2 * 5 = 10
  14 - 10 = 4

Here's another example <em>[ex. 3 mod6]</em>

  6 goes into 3, (0x)
  0 * 6 = 0
  3 - 0 = 3

<em>Theres documentation online and on the command line called `pydoc`, for example you can look up individual things
e.g. `pydoc enumerate`, enumerate is a function that takes two parameters, one for the `index`'s size, and one for its `value`.
By that same token, `len(a)` is logically similar to accessing the size of an array w/ `sizeof(array)`
in C, as it is used to get the length of objects and arrays</em>

We've probably looked at For loops a billion*times, nevertheless lets look at one again to fully understand
both a For loop, and how its more efficient w/ `yield`; First, using a non-yielding example:
<span class="alt-text">
  def fibonacci(n):
      sequence = []
      a, b = 0, 1
      for _ in range(n):
          sequence.append(a)
          a, b = b, a + b
      return sequence
  result = fibonacci(8)</span>

(`_`) Underscore informs the loop that we dont want to use a loop variable in the loop body. And just to explain the
reason for this—Since you don’t need the loop counter (e.g., i) for anything inside the loop, the `_` indicates the
variable is unused, keeping the code cleaner.

`range`, means we are iterating `n` amount of times (`n` elements). `append` appends the 'current' value `a` to the sequence.
`a, b = b, a + b` ("sequence unpacking", technical term) its really just doing regular assignment. it only looks strange a
Python lets you do arithmetic during assignment—in short, `a` takes the value of the previous `b`, and `b` takes the sum of
the previous values of `a` and `b`; And, it might sound complicated explained like that, but its just regular assignment
that goes through iteration, period.

Its preferred to use a generator w/ `yield`  in the case of iterating over a large amount of data,
or data you dont need "all at once"
<span class="alt-text">
  def fibonacci(n):
      a, b = 0, 1
      for _ in range(n):
          yield a
          a, b = b, a + b
  result = list(fibonacci(8))</span>

We get the current fibonacci number and pause anytime we encounter `yield`, until the next iteration: `a, b = b, a + b`
When we call &amp; convert  `fibonacci` to a `list` array, it consumes and collects all the values generated
by the `yield` statement. The program has encountered the value we want for `range`,
so we can return to `yield` and properly iterate through.
<span class="alt-text">
  my_list = ['element1', 'element2', 'element3']
  for index, item in enumerate(my_list):
      print(index, item)</span>

I just want to recap; functions in Python encapsulate arrays, and we explained how `enumerate` works, but
lets look at another example that involves iterating over a <em>class</em>.
<b>youll notice, Python lets you inherit `.objects` from <u>EVERYTHING</u>, literally</b>
<span class="alt-text">
  class NameClass:
      def __init__(self, data):
          self.data = data
          self.index = 0

      def __iter__(self):
          return self

      def __next__(self):
          if self.index &gt;= len(self.data):
              raise StopIteration
          value = self.data[self.index]
          self.index += 1
          return value

  function = NameClass(['element1', 'element2', 'element3'])
  for item in function:
      print(item)</span>

- A function that takes two parameters, `self` (which refers to the instance of the class) and `data`
  (which is the list we want to iterate over)
- Assign `self.data`, so that it can be accessed throughout the class. We initialize `index` to keep
  track of the current position in the list `data`
- `__iter__` is used in a loop. It returns an iterator object, in this case, it returns `self`.
- Every time the next element is needed in the iteration, i.e. `__next__`.
- If the index is greater than or equal to the length of the data list. If it is, it means we've
  reached the end of the list, so we raise a `StopIteration` exception to signal the end of iteration.
- `value = self.data[self.index]`, retrieve's the value at the current index from the `data` list.
- Then, increment the index so that the next time `__next__` is called, it will retrieve the next
  element in the list.
- Finally, we return the value retrieved from the list. Then after we assign `function`, we iterate
  over the list and print each item. This demonstrates both iteration within a class, assigning a function
  to a class and the encapsulation of functions/classes.

Lets show another, to demonstrate the versatility of types and classes... We briefly mentioned how
`func(var:type)` lets you annotate a type of some variable, and we might of seen how we assign functions,
but look at how we assign a dictionary in the following:
<span class="alt-text">
  class Counter:
      def __init__(self, iterable=None):
          self.data = {}
          if iterable:
              self.update(iterable)
    
      def update(self, iterable):
          for item in iterable:
              self.data[item] = self.data.get(item, 0) + 1
    
      def __getitem__(self, item):
          return self.data.get(item, 0)</span>

- In short, we are initializing a variable to an empty dictionary, which  allows you
  to store elements inside said variable thats now associated w/ the dictionary.
- Then in the update method, the `iterable` argument represents a collection of elements
  that you want to count. The For loop iterates over each element (item) in the iterable.
- For each item, the method updates the count in the dictionary `self.data`.
  `self.data[item]` accesses the value (count) associated with the current item.
  `self.data.get(item, 0)` returns the current count of item, or 0 if item is
  not already in `self.data`, <em>notice we are storing an element (`item`)
  inside said variable which is now associated w/ said dictionary, and we
  made it w/ an "arrlist".</em> `self.data[item] = self.data.get(item, 0) + 1`
  increments the count of item by 1 and updates it in the dictionary, and
  we are using it as a regular function to specify each argument.

Now using this function, we would do something like the following
<span class="alt-text">
  def display_rate(counter: Counter[str]) -&gt; None:</span>

This demonstrates the versatility of classes, as well as how a function can be a type
of any array, by which you can associate the `[]` arrlist w/ subsequent array type.

I want to show one more example, this time portraying inheritance (like its 1999 again)
and the way it looks in Python (we leave out the part that requires calling said methods)

And for shits and gigs we include f"strings to embed expressions inside of string literals:

  # Base class for tasks<span class="alt-text">
  class Task:
    def __init__(self, title, description):
        self.title = title
        self.description = description

    def display_info(self):
        print(f"Task: {self.title}")
        print(f"Description: {self.description}")

    def mark_as_completed(self):
        print(f"Task '{self.title}' is completed.")</span>

  # Subclass for work-related tasks<span class="alt-text">
  class WorkTask(Task):
    def __init__(self, title, description, deadline):
        super().__init__(title, description)
        self.deadline = deadline

    def display_info(self):
        super().display_info()
        print(f"Deadline: {self.deadline}")</span>

  # Subclass for personal tasks<span class="alt-text">
  class PersonalTask(Task):
    def __init__(self, title, description, priority):
        super().__init__(title, description)
        self.priority = priority

    def display_info(self):
        super().display_info()
</span>
Notice that the subclass `WorkTask` inherits from `Task` (when it appears in parentheses,
it is referred to as the "base class" of which the "child class" (`WorkTask`) inherits.

In terms of functionality, it adds an attribute specific to work-related tasks (like a deadline,
or something...). The `display_info` method is overridden to also display the deadline.

The `PersonalTask` subclass also inherits from `Task` and adds a priority attribute specific
to the personal tasks. The `display_info` method is overridden to also display the priority.

In conclusion, I thought it would be best to go over arrays, loops, iteration, and other
such things that give us a window into the world of Python. One last note, there is an
itertools module in Python that provides a collection of fast, memory-efficient tools
for working w/ iterators. It's designed for manipulating iterable sequences, and are
particularly useful when you need to generate, or process sequences without creating
large data structures in memory, or to add to the nuances of iterables in general.

Congratulations, you've now learned the green eggs and ham, as well as all the array
and iteration methods in Python. Just practice those examples over and over and youll
have memorized how Python works. You might also consider trying C-Extended Python or
(Cython) which has a better runtime performance by adding an extra step of compilation.

The same is true of Nuitka, in that it can translate Python into C, and then compile it
into native machine code, and this could be particularly beneficial while working w/
large projects remotely. The explicitly-static type of syntax makes these things
particularly C-like, and the fact that you can have a bridge between higher and
lower level languages is what makes these things intriguing, since you are see-
ing a higher level system described, and how it is mapped in the C World, see?
</body></html>
